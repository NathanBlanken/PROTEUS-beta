% =========================================================================
% RUN THE SIMULATION
% input:    kgrid
%           pulse
%           medium
%           source
%           sensor
% output:   sensor_data 
% 
% Compute sensor data of waves generated by oscillating microbubbles in a 
% homogeneous medium. Nonlinear propagation is neglected.
% 
% =========================================================================
function sensor_data = run_simulation_homogeneous(...
    run_param, kgrid, medium, source, sensor)

% Compute the average properties of the medium (homogeneous medium 
% approximation):
medium = average_medium(medium);

N_source    = size(source.points,1);   	% Number of sources
N_sensor    = size(sensor.points,1);   	% Number of sensors

% Preallocate sensor data:
dataType = class(source.mass_source); % 'single' or 'double'
if strcmp(run_param.DATA_CAST,'gpuArray-single') || ...
   strcmp(run_param.DATA_CAST,'gpuArray-double')
    gpuDevice(run_param.DEVICE_NUM + 1);
    sensor_data.p      = gpuArray(zeros(N_sensor,kgrid.Nt, dataType));
    source.mass_source = gpuArray(source.mass_source);
else
    sensor_data.p = zeros(N_sensor,kgrid.Nt, dataType);
end

for m = 1:N_source 
    
    disp(['Propagating source ' num2str(m) '/' num2str(N_source) ' ...'])
    
    mass_source = source.mass_source(m,:);
      
    % Compute the distance between source m and the sensor points:
    d0 = vecnorm(sensor.points-source.points(m,:),2,2);
       
    if run_param.gridded
        % Map values of d on a grid to reduce computation time:
        [d, i_sampled] = gridded_distance(d0, kgrid.dt*medium.c);
    else
        d = d0;
    end
       
    % Convert to requested data type:
    if strcmp(run_param.DATA_CAST,'gpuArray-single') || ...
       strcmp(run_param.DATA_CAST,'gpuArray-double')
        d = gpuArray(cast(d,dataType));
    else
        d = cast(d,dataType);
    end
  
 	% Compute the signal emitted by source m, sensed by the sensor 
    % points:  
    p = calc_scatter_attenuated(mass_source,medium,kgrid,d);
     
    % Prevent sources from self-sensing:         
    p(d0 == 0,:) = 0;
    
    % Add the sensed echo to the sensor data:
    if run_param.gridded
        sensor_data.p = sensor_data.p + p(i_sampled,:);
    else
        sensor_data.p = sensor_data.p + p;
    end
    
end

end


function medium_average = average_medium(medium)
% Compute the average value of medium properties.

medium_average.rho = mean(medium.density,     'all');
medium_average.c   = mean(medium.sound_speed, 'all');
medium_average.a   = mean(medium.alpha_coeff, 'all');
medium_average.b   = mean(medium.alpha_power, 'all');

if isfield(medium,'alpha_mode')
    medium_average.alpha_mode = medium.alpha_mode;
end

end

function [d_grid, i_grid] = gridded_distance(d, dx)
% Snap values in array d to a grid d_grid with step size dx. 
% Grid is set up with respect to mean of d. 
% The indices i_grid are defined such that d_grid(i_grid(n)) is the element
% closest to d(n).

    % Set up grid:
    i_grid = round((d - mean(d))/dx);
    d_grid = (min(i_grid):max(i_grid))*dx + mean(d);
    d_grid = transpose(d_grid);
    
    % Return indices of grid corresponding to elements in d:
    i_mean = -min(i_grid) + 1;
    i_grid = i_grid + i_mean;

end